..  _hw4:

HW4: How Fast is My Code?
#########################

    * Reference: :cite:`Soon:2000`

..  include::   /references.inc

For some reason, we all want our computers to be FAST! So, as programmers, we
need a way to figure out just how fast our programs (or parts of our programs)
are. While we could pull out a stop-watch and time things ourselves, it is much
more efficient to let the machine help you get this information.

..  note::

    For this assignment, you do not need to submit any code,
    just a document in your homework repo showing the results you got on
    your system. You will run the code shown here and record your resuts as
    Homework 5.


Tick Tick
*********

As we discussed earlier, the processor is driven by a simple clock circuit that
generates an on-off (0-1) pattern at some pretty fast rate. The manufacturer of
your computer decides how fast that will be, based on how fast the actual chip
they select can go. (Geeks have been known to :term:`over-clock` their
processors to make those space aliens go away faster, but that has its own
risks in terms of potential damage to the chip!)

How can a machine tell us how fast it is going?

Determining Clock Speed
=======================

All modern computers, at least those desktop or laptop systems) have several
timing systems active in them. The processor clock is probably the most
important, but it stops when power is pulled from the system. To enable the
computer to track the time of day, there is another clock in the system, this
one run by batteries so it will continue to tick away while the machine is
powered off.

Real-Time Clock
===============

On the motherboard of your system, you will find a crystal controlled chip that
ticks at a rate of 32768 Hz (a common rate, used in many watches). This chip
provides a signal to the processor at a rate of 1024 Hz. The chip has registers
that keep track of the current time and date used by your system in many ways.
Unfortunately, this chip is known to "drift" off of the real time, so most
systems use :term:`Network Time Synchronization` (or :term:`NTP`) to update the
registers in this chip using more accurate sources provided by a number of
servers on the Internet. 

Counter/Timer Chip
==================

There is another chip on the motherboard generating a signal that is sent to
the processor for time keeping purposes, but this one, like the main system
clock, only runs when power is available.

The `CTC` chip is clocked at a rate of 14.31818 MHz, and gets divided down to
generate a signal at a rate of 1.193182 MHz. This gets further divided to give
a final signal at a rate of 18.2065 Hz. 

Signals generated by this chip are used by the operating system in deciding
what job gets the processor's attention. We will learn more about how this
happens when we study :term:`interrupts` later in the course.

Time-Stamp Counter
==================

The most accurate time source is the chip, itself. The Pentium processor
maintains a 64-bit counter that is incremented every time the system clock
ticks. When the system is powered on, or reset, this counter returns to zero.
Even with a fast system clock, with 64-bits it will take a while to get to the
biggest number you can hold in 64-bits. (See :ref:`HW2`) to find out
how long!)

There is an instruction you can use to access this counter: `RDTSC`. When you
process this instruction, two internal "registers" get set (see the Intel docs):

    * RAX = low 32 bits of counter (high 32 bits are all zero)

    * RDX = high 32 bits of counter (high 32 bits are all zero)

Both of these registers hold 64 bits.

..  note::

    It is possible for the operating system to disable this instruction, and it
    is possible that each processor in a multi-code chip might have different
    counter values. Synchronizing the counters in all cores can be done with a
    suitable program (we will not explore that issue here).

There are a few issues when using this instruction to see how fast things are
going. For one, the magic in the processor allows it to be working on more than
one instruction at a time, making the count less useful for calculating the
time one instruction takes. We can defeat the chip by forcing it to flush out
the places where this work is happening, effectively rendering it a simple
machine where we can time single instructions. A common way to do this is to
use the `CPUID` instruction right before calling the `RTDSC` instruction. A
side effect of `CPUID` is to do the flushing job we want. 

Here is a bit of `C` code we can use to get the processor to return the `TSC`
values:

..  literalinclude::    code/rdtsc.c
    :language: c
    :linenos:
    :caption: rdtcs.c

..  literalinclude::    code/rdtsc.h
    :language: c
    :caption: rdtsc.h

..  note::

    This bit of trickery shows you that you can drop from C into assembly
    language without moving completely to assembly language. You need to know
    what is going on, though, otherwise you might really mess up your program!

As a demonstration of using this instruction to time a single instruction,
let's try this code:

..  literalinclude::    code/test_mov.c
    :linenos:
    :language: c

And here is what we get:

..  code-block:: text

    $ gcc -o test_mov test_mov.c rtdcs.c
    $ ./test_mov
    $ MOV took 27 cycles

That does not seem right, the processor should be able to do this job much more
quickly. Actually, it does. It should be able to do this job in just one clock
cycle. So, what is wrong with our experiment?

The answer is a bit complicated. If we disassembly the code produced by this
test, we see this:

..  literalinclude::    code/test_mov.s
    :linenos:

That is a lot more code than I wanted to test. It looks like the test, itself,
generated some "overhead" that we need to account for. One way to do this is to
run the test a second time, this time doing everything except the one
instruction we are interested in timing. Here is a modified version of the
program that does this:

..  literalinclude::    code/test_mov2.c
    :linenos:
    :language: c

Running this give the following:

..  code-block:: text

    $ gcc -o test_mov2 test_mov2.c rdtsc.c
    $ ./test_mov2
    MOV took 6 cycles

Well, that is better, but it is still wrong! We should be seeing numbers closer
to one. In fact, running this a number of times, I saw values ranging from 0 to
2753 cycles. What is going on?

Multi-tasking
*************

The answer is simple. It is all those "other" programs running in your system
that are causing all the pain. In the simple code we ran, the operating system
might interrupt our code and hand control to a totally different program, one
that consumes a bunch of cycles to get done. If this happens, the count we
finally get will be totally wrong. Is there any way to avoid this problem?

..  note::

    Probably, the master of this kind of timing is Agner Fog (AgnerFog_) who
    has worked very hard to produce accurate timing data for a bunch of
    processors. The code he uses is available from his web site.

In order to do this job accurately, we have to force the operating system to
stop interrupting our job, and deal with a number of internal issues such as
the systems ability to do a form of parallel processing as it processes
individual instructions. Rather than go through all of that now, I will refer
you to Agner's website, and we will use his data as a source for the number of
cycles each instruction takes to complete. We will use our `RDTSC` routine when
we need to do timing calculations in our example code.

Checking Your System Clock
**************************

Using the `RDTSC` routine we presented, we can get the frequency of our system
clock with reasonable accuracy using this code:

..  literalinclude::    code/freq.c
    :linenos:
    :language: c

This routine assumes that the system `sleep` command, which uses the CTC
counter to do its job, is accurate enough to actually stall the program for
exactly one second. On my system, this is what I got:

..  code-block:: text

    gcc -o freq freq.c rdtsc.c
    ./freq
    clock frequency = 2641482962

According to Apple, my MacBook Pro is running at 2.7GHz, which is close enough
for me.

The Makefile
************

Just to complete this lecture, here is a Makefile that will build all the code.

..  literalinclude::    code/Makefile
    :linenos:

What to Turn In
***************

Obviously, you do not need to create any new code for this project, but oyu do
need to set up this experiment and see what you get on your development
machine. To complete the homework, just record your results in a text file and
include that in your homework repo. Be sure to run the instruction timing code
a few times to see how it varies.

..  vim: set filetype=rst spell
