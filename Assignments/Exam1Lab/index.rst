..  _exam-1-lab:

COSC2325 Exam 1 Lab
###################

..  include::   /references.inc

..  note::

    This lab is worth 50 points on your first exam. Complete this work, and
    upload a text file documenting your results in your GitHub Homework Repository.
    Place the file in a folder named **Exam1**.

This project is an experiment in decoding what is going on when we call a
simple function in a high level language. We have not studied this in class
yet, but you do know enough about simple assembly language to try to follow the
processor as it calls a function.  Don't worry that you do not understand all
of this yet.  Just take notes as you see new instructions, look things up, and
think about what is going on.

Background
**********

The instruction that branches to the function code is named ``call`` and the
instruction that returns from that function is ``ret``.

The Pentium processor uses one part of available RAM as a stack (a *Last-in
First-out* data memory), and manages this area using a register named ``RSP``.
Any reference to that register is referring to the current "top of stack". The
Pentium provides simple instructions to add something to the top of the stack,
and retrieve something from the top of stack later. All items on the stack are
64-bits big.

When a subroutine is called, the return address is pushed onto the stack as
part of executing the call. That address is popped off of the stack by the
``RET`` instauction. While the routine is working the ``RBP`` register is set
up to point into the stack where we can store local data. You will see
references to that area in the code below.

The assembly language you will see in this project was generated by the
compiler. It includes notation that we are not adding to our simple machine.
For example ``DWORD PTR [xxx]`` means that the address ``xxx`` is pointing to a
``DWORD`` and we are referring to that 32 bit value stored in memory. The
square brackets are supposed to remind you that we are not talking about an
address of something in memory, but the actual data stored at that address. (It
looks like an array reference).

Registers that are named beginning with an ``R`` are 64 bit registers, those
starting with ``E`` are 32 bit registers.  However, Intel created aliases for
parts of some 64 bit register. For instance, if ``RAX`` names a 64-bit register,
``EAX`` refers to the lower 32 bits of that same register. Similarly, ``AX``
refers to the low 16 bits. (Blame that on legacy code from earlier machines)

The compiler uses the stack for temporary storage of local variables while a
function is running. All variable names have been eliminated, and the ``RBP``
register has been set up to point to a block of memory in this stack where
local variables will live.  So, something like ``[RBP-4]`` actually refers to a
local variable. 

..  note::

    That actually explains why variables you define in a function seem to
    "disappear" when you exit the function, and cannot be used when you call it
    again. They are "temporary" variables living on that stack, and that memory
    gets reused by other functions as they work!

Your Job
********

Here are two short "C" program files, and a stripped down version of what the
compiler produced for each. 

..  literalinclude::    code/main.txt
    :linenos:
    :caption: main.c

..  literalinclude::    code/proc.txt
    :linenos:
    :caption: proc.c

Copy the provided code to a text file, and try to explain what is going on. 

You only need to explain the code marked off by the lines between the
``;------`` markers in the assembly language.

Figuring this out may take a bit of searching on Google (to figure out what
each instruction does). Some will be familiar from your lab projects. Others
may take looking up.

After completing your notes, step back and see if you can see how the ``proc``
procedure found the parameter it needed to generate the message, and how that
value was sent to the ``printf`` function. 

Add a paragraph explaining what you figured out about how that all works.

..  note::

    We will be studying this whole topic in more detail later. This lab is just
    checking to see if you can follow example code and come up with a sense of
    what happens in each step.  You may miss some details, but the overall
    action should make some sense , based on your programming experience.

